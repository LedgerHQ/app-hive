/*****************************************************************************
 *   Ledger App Hive
 *   Based on (c) 2020 Andrew Chaney
 *   Modifications (c) 2021 Bartłomiej (@engrave) Górnicki
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *****************************************************************************/

#include "os.h"
#include "cx.h"
#include <string.h>
#include "constants.h"

/**
 * The nonce generated by internal library CX_RND_RFC6979 is not compatible
 * with Hive. So this is the way to generate nonce for Hive.
 */
void rng_rfc6979(unsigned char *rnd,
                 unsigned char *h1,
                 unsigned char *x,
                 unsigned int x_len,
                 const unsigned char *q,
                 unsigned int q_len,
                 unsigned char *V,
                 unsigned char *K) {
    unsigned int h_len, found, i;
    cx_hmac_sha256_t hmac;

    // a. h1 as input
    h_len = DIGEST_LEN;

    // loop for a candidate
    found = 0;
    while (!found) {
        if (x) {
            // b.  Set: V = 0x01 0x01 0x01 ... 0x01
            memset(V, 0x01, h_len);

            // c. Set: K = 0x00 0x00 0x00 ... 0x00
            memset(K, 0x00, h_len);

            // d.  Set: K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1))
            V[h_len] = 0;
            cx_hmac_sha256_init(&hmac, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, 0, V, h_len + 1, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, 0, x, x_len, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, CX_LAST, h1, h_len, K, DIGEST_LEN);

            // e.  Set: V = HMAC_K(V)
            cx_hmac_sha256_init(&hmac, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, CX_LAST, V, h_len, V, DIGEST_LEN);

            // f.  Set:  K = HMAC_K(V || 0x01 || int2octets(x) || bits2octets(h1))
            V[h_len] = 1;
            cx_hmac_sha256_init(&hmac, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, 0, V, h_len + 1, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, 0, x, x_len, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, CX_LAST, h1, h_len, K, DIGEST_LEN);

            // g. Set: V = HMAC_K(V) --
            cx_hmac_sha256_init(&hmac, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, CX_LAST, V, h_len, V, DIGEST_LEN);

            // initial setup only once
            x = NULL;
        } else {
            // h.3  K = HMAC_K(V || 0x00)
            V[h_len] = 0;
            cx_hmac_sha256_init(&hmac, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, CX_LAST, V, h_len + 1, K, DIGEST_LEN);

            // h.3 V = HMAC_K(V)
            cx_hmac_sha256_init(&hmac, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, CX_LAST, V, h_len, V, DIGEST_LEN);
        }

        // generate candidate
        /* Shortcut: As only secp256k1/sha256 is supported, the step h.2 :
         *   While tlen < qlen, do the following:
         *     V = HMAC_K(V)
         *     T = T || V
         * is replace by
         *     V = HMAC_K(V)
         */
        x_len = q_len;
        while (x_len) {
            if (x_len < h_len) {
                h_len = x_len;
            }
            cx_hmac_sha256_init(&hmac, K, DIGEST_LEN);
            cx_hmac((cx_hmac_t *) &hmac, CX_LAST, V, h_len, V, DIGEST_LEN);
            memmove(rnd, V, h_len);
            x_len -= h_len;
        }

        // h.3 Check T is < n
        for (i = 0; i < q_len; i++) {
            if (V[i] < q[i]) {
                found = 1;
                break;
            }
        }
    }
}
